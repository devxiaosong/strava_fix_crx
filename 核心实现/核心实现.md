# Strava Bulk Edit - 核心执行流程

## 概述

用户在配置界面完成筛选条件和更新值的设置后，有两个执行路径：

1. **预执行 (Preview)** - 点击"Preview"按钮，先查看将要匹配的活动
2. **直接执行 (Execute Now)** - 点击"Execute Now"按钮，跳过预览直接执行

---

## 一、预执行流程 (Preview)

### 目标
扫描所有活动，找出符合筛选条件的活动并展示给用户，**不进行任何实际的数据修改**。

### 输入数据
- **场景类型** (scenario): 'bikes' | 'shoes' | 'privacy' | 'ride_type'
- **筛选条件** (filters) - 用于构建 Rule 的 Conditions:
  - 运动类型 (sportTypes): 根据场景自动确定或用户选择
  - 时间范围 (dateRanges): **可选**，可以有0个或多个时间段
  - 距离范围 (distanceRange): **可选**，[最小值, 最大值]
  - 骑行类型 (rideTypes): **可选**，仅骑行场景
  - ⚠️ **注意**: 所有筛选条件都是可选的，如果都不设置则匹配所有活动
- **更新值** (updates):
  - 装备ID (gearId): 自行车ID或跑鞋ID
  - 隐私设置 (privacy): 'everyone' | 'followers_only' | 'only_me'
  - 骑行类型 (rideType): 仅骑行类型场景

---

### 步骤详解

#### Step 0: 预览前的准备和检查

**重要**: 预览也需要确保页面状态正确，才能准确统计匹配的活动

---

**0.1 页面归位和排序检查**

与执行流程相同的检查要求：

1. **回到第一页**:
   - 检测当前页码
   - 如果不是第1页，自动翻回第1页
   - 确保从头开始扫描，不遗漏活动

2. **确认时间降序排列**:
   - 验证列表按时间降序（最新在最上方）
   - 这对时间范围 Condition 的准确性至关重要
   - 如果排序不对，提示用户调整

3. **基础环境检查**:
   - 在正确的页面
   - 用户已登录
   - 必要的 DOM 元素存在

**为什么预览也需要这些检查**:
- 预览结果要准确反映将要更新的活动
- 如果预览时页面状态不对，执行时可能结果不同
- 用户基于错误的预览做决策会导致意外结果

---

#### Step 1: 初始化预览状态
- 显示"正在扫描..."的加载界面
- 初始化计数器:
  - 已扫描活动数: 0
  - 匹配活动数: 0
  - 当前页码: 1
- 初始化进度: 0%

---

#### Step 2: 获取活动列表

**2.1 设置API请求监听器**
- 在页面加载时，设置网络请求拦截器
- 监听目标URL: `https://www.strava.com/athlete/training_activities`
- 使用 XMLHttpRequest 或 Fetch 拦截技术
- 目的: 捕获 Strava 页面自己发起的API请求响应

**2.2 通过DOM操作触发翻页**
- 找到"下一页"按钮: `button.next_page`
- 点击按钮触发页面翻页
- Strava 页面会自动发起API请求获取新页面数据
- 我们的监听器会捕获这个请求的响应

**2.3 拦截并解析响应数据**
- 监听器捕获到API响应后，解析JSON数据
- 获取活动列表数组 (models)
- 获取总活动数 (total) - 仅第一次请求返回
- 获取当前页码 (page)
- 获取每页数量 (perPage)

**2.4 计算总页数**
- 如果是第一页，计算: 总页数 = Math.ceil(总活动数 / 每页数量)
- 保存总页数，用于进度计算

**2.5 为什么采用"监听+DOM操作"而非直接发请求**
- ✅ **更可靠**: 复用 Strava 页面的认证和请求逻辑，避免 CSRF 等问题
- ✅ **更可控**: 可以同步页面状态，确保数据和UI一致
- ✅ **更隐蔽**: 行为更接近用户手动操作，不容易被检测
- ✅ **更稳定**: 不需要维护独立的请求逻辑和认证机制

---

#### Step 3: 筛选匹配活动（规则引擎）

对当前页的每个活动，通过**规则引擎 (Rule Engine)** 判断是否匹配。

一个 **Rule（规则）** 由0个或多个 **Condition（条件）** 组成：
- **如果有 Conditions**: 所有启用的条件必须同时满足
- **如果没有 Conditions**: 匹配所有活动（无筛选）

---

**可选 Condition 1: 运动类型匹配**
- 根据场景确定固定的运动类型:
  - 'bikes' 或 'ride_type' → 只匹配 'Ride'
  - 'shoes' → 只匹配 'Run'
  - 'privacy' → 根据用户选择的运动类型筛选
- 判断: 活动的 sport_type 是否在允许的类型列表中
- **如果未启用**: 跳过此条件，视为通过

**可选 Condition 2: 时间范围匹配**
- **如果用户设置了时间范围**（可以是多个时间段）:
  - 获取活动的时间戳 (start_date_local_raw)
  - 检查是否落在**任意一个**时间段内
  - 只要命中一个时间段即为匹配
- **如果未设置时间范围**: 跳过此条件，视为通过

**可选 Condition 3: 距离范围匹配**
- **如果场景需要距离筛选** ('bikes', 'shoes', 'ride_type'):
  - 获取活动的距离 (distance_raw)，单位是米
  - 转换为公里: 距离(km) = distance_raw / 1000
  - 转换为英里: 距离(mi) = distance_raw / 1609.34
  - 判断: 距离是否在 [最小距离, 最大距离] 范围内
- **如果未启用距离筛选**: 跳过此条件，视为通过

**可选 Condition 4: 骑行类型匹配**
- **如果是 'bikes' 场景且用户设置了骑行类型筛选**:
  - 获取活动的当前骑行类型 (selected_tag_type)
  - 判断: 是否在用户选择的骑行类型列表中
- **如果未设置骑行类型筛选**: 跳过此条件，视为通过

---

**Rule 执行逻辑**

```
Rule 匹配 = 
  (Condition1 未启用 OR Condition1 通过) AND
  (Condition2 未启用 OR Condition2 通过) AND
  (Condition3 未启用 OR Condition3 通过) AND
  (Condition4 未启用 OR Condition4 通过)
```

**特殊情况**:
- 如果所有 Conditions 都未启用 → Rule 匹配所有活动
- 只有启用的 Conditions 需要满足

---

#### Step 4: 更新预览进度

**4.1 更新计数**
- 已扫描活动数 += 当前页的活动数量
- 匹配活动数 += 当前页符合条件的活动数量

**4.2 计算进度**
- 进度百分比 = (当前页码 / 总页数) × 100%

**4.3 更新UI显示**
- 更新进度条
- 显示已扫描数量
- 显示已匹配数量

---

#### Step 5: 判断是否继续扫描

**5.1 检查是否有下一页**
- 判断: 当前页码 < 总页数
- 或者从DOM检查"下一页"按钮是否可用

**5.2 如果有下一页**
- 点击"下一页"按钮（DOM操作）
- 等待监听器捕获新的API响应
- 页码 +1
- 返回 Step 2，继续处理下一页

**5.3 如果没有下一页**
- 扫描完成，进入 Step 6

---

#### Step 6: 展示预览结果

**6.1 关闭加载状态**
- 隐藏"正在扫描..."提示
- 隐藏进度条

**6.2 显示匹配结果**
- 显示匹配活动总数
- 以表格形式展示匹配的活动列表，包含:
  - 运动类型图标
  - 日期
  - 活动名称
  - 距离
- 表格可滚动查看所有活动

**6.3 提供操作按钮**
- **[Start Execution]** 按钮 - 开始真正执行
- **[返回修改]** 按钮 - 返回配置界面调整条件

---

### 输出结果
- **匹配的活动列表**: Activity[]
- **匹配活动总数**: number
- **用户决策**: 继续执行 or 返回修改

---

## 二、真正执行流程 (Execute)

### 目标
遍历所有页面，找出符合条件的活动，并**真正修改**它们的数据。

### 触发方式
1. 从预览页面点击"Start Execution"
2. 从配置页面直接点击"Execute Now"（跳过预览）

### 输入数据
与预览流程相同的:
- 场景类型 (scenario)
- 筛选条件 (filters) - 构建 Rule 的 Conditions（可选，可以为空）
- 更新值 (updates)

**重要**: 如果 filters 中所有 Conditions 都未启用，则会更新**所有**活动

---

### 步骤详解

#### Step 0: 执行前的准备和检查

**重要**: 在开始执行前，必须确保页面处于正确的初始状态

---

**0.1 页面归位检查（回到第一页）**

**为什么必须回到第一页**:
- 用户可能正在浏览第5页时点击执行
- 如果从第5页开始 → 前4页的活动会被遗漏
- 必须从第1页开始遍历，确保不遗漏任何活动

**检查和处理步骤**:
1. 检测当前页码
   - 从 DOM 读取: `.pagination .active` 的页码
   - 或从 URL 参数读取: `?page=X`
   
2. 如果不是第1页:
   - 方案A: 自动点击"第一页"按钮（如果有）
   - 方案B: 连续点击"上一页"直到回到第1页
   - 每次点击后等待页面加载完成（约2秒）
   
3. 验证已回到第1页:
   - 检查页码高亮显示为 "1"
   - 检查 URL 没有 page 参数或 page=1

---

**0.2 排序方式检查（按时间降序）**

**为什么必须按时间排序**:
- **时间范围筛选可靠**: 只有按时间排序，时间范围 Condition 才能准确匹配
- **智能翻页优化生效**: 可以检测"当前页所有活动都早于最早时间"，提前终止遍历
- **断点续传可预测**: 知道第X页对应哪个时间段，恢复时更可靠
- **避免遗漏**: 其他排序（距离、海拔等）会导致日期混乱，无法判断是否遍历完整

**Strava 排序选项**:
- 按日期排序（默认）- 最新活动在最上方 ✅ **需要这个**
- 按距离排序 ❌ 
- 按时间排序 ❌
- 按海拔排序 ❌

**检查和处理步骤**:
1. 检测当前排序方式
   - 查找排序控件: `select[name="sort"]` 或排序按钮
   - 读取当前选中的排序值
   - 期望值: "date" 或 "start_date" 降序

2. 验证排序结果（更可靠）
   - 获取前3个活动的时间戳
   - 检查: 时间戳1 > 时间戳2 > 时间戳3
   - 确认是按时间降序排列

3. 如果排序不正确:
   - **方案A** (推荐): 提示用户手动调整
     - 显示明确提示："请确保列表按日期排序（最新活动在最上方）"
     - 提供操作指引和截图
     - 等待用户确认已调整
   
   - **方案B**: 尝试自动调整（如果 DOM 允许）
     - 模拟点击排序按钮
     - 等待页面刷新
     - 验证排序是否正确

---

**0.3 环境和权限检查**

1. **页面验证**:
   - 确认在 Strava 训练日志页面
   - URL 包含 `/training/log` 或 `/training/activities`
   - 必要的 DOM 元素存在

2. **登录状态**:
   - 尝试获取 Athlete ID
   - 检查认证状态

3. **任务冲突检查**:
   - 检查是否有未完成的任务
   - 如果有，提示用户选择：继续 or 放弃

4. **配置有效性**:
   - 如果涉及装备，验证装备 ID 仍存在
   - 验证场景和更新值匹配

---

**0.4 监听器初始化**

- 设置 API 拦截器
- 监听 `/athlete/training_activities` 请求
- 准备捕获响应数据

---

**0.5 检查清单（执行前必须满足）**

- ✅ 页面已归位到第1页
- ✅ 列表按时间降序排列
- ✅ 用户已登录
- ✅ 在正确的页面
- ✅ 没有任务冲突（或已处理）
- ✅ 配置有效
- ✅ 必要的 DOM 元素存在
- ✅ API 监听器已设置

**如果任何检查失败**:
- 显示明确的错误提示
- 提供解决建议
- 允许用户取消或重新配置

---

#### Step 1: 初始化执行环境

**1.1 初始化状态**
- 当前页码: 1
- 总页数: 未知（需遍历获取）
- 执行统计:
  - 已处理活动数: 0
  - 成功数: 0
  - 失败数: 0
- 失败活动列表: []
- 是否暂停: false
- 开始时间: 当前时间戳

**1.2 显示执行界面**
- 打开执行进度Modal
- 显示标题: "正在执行批量更新..."
- 显示初始进度: 0%
- 显示"暂停"按钮

**1.3 保存任务状态**
- 将任务配置保存到 Chrome Storage
- 包含: 场景、筛选条件、更新值、执行进度
- 用于支持中断恢复

---

#### Step 2: 处理当前页面

**2.1 点击所有"快速编辑"按钮**
- 找到当前页所有活动的"快速编辑"按钮
- CSS选择器: `.training-activity-row .quick-edit`
- 依次点击所有按钮
- 这会打开每个活动的内联编辑表单

**2.2 等待编辑表单出现**
- 延迟 500ms，等待DOM更新
- 确保所有编辑表单已渲染完成

---

#### Step 3: 筛选并填充数据

**3.1 获取当前页所有活动的表单**
- 找到所有活动行: `.training-activity-row`

**3.2 对每个活动执行规则匹配**
- 使用与预览相同的**规则引擎 (Rule Engine)**
- 判断活动是否满足所有 Conditions（即匹配该 Rule）

**3.3 如果活动匹配 Rule，填充修改值**

根据场景填充不同的字段:

**场景 S1: 批量更新自行车 (bikes)**
- 找到自行车选择框: `select[name="bike_id"]`
- 设置值为用户选择的自行车ID
- 如果用户勾选了"同时更新隐私":
  - 找到隐私选择框: `select[name="visibility"]`
  - 设置值为用户选择的隐私设置

**场景 S2: 批量更新跑鞋 (shoes)**
- 找到跑鞋选择框: `select[name="athlete_gear_id"]`
- 设置值为用户选择的跑鞋ID
- 如果用户勾选了"同时更新隐私":
  - 找到隐私选择框: `select[name="visibility"]`
  - 设置值为用户选择的隐私设置

**场景 S3: 调整隐私设置 (privacy)**
- 找到隐私选择框: `select[name="visibility"]`
- 设置值为用户选择的隐私设置

**场景 S4: 标记骑行类型 (ride_type)**
- 找到骑行类型选择框: `select[name="workout_type_ride"]`
- 设置值为用户选择的骑行类型
- 如果用户勾选了"同时更新隐私":
  - 找到隐私选择框: `select[name="visibility"]`
  - 设置值为用户选择的隐私设置

**3.4 如果活动不匹配**
- 跳过，不修改任何值

---

#### Step 4: 提交所有修改

**4.1 等待表单更新**
- 延迟 300ms，确保表单值已更新

**4.2 点击所有提交按钮**
- 找到所有提交按钮: `.training-activity-row button[type="submit"]`
- 依次点击所有按钮
- 这会触发 Strava 的保存请求

**4.3 等待提交完成**
- 延迟 1500ms，等待所有请求完成
- 等待页面刷新和DOM更新

**4.4 更新统计**
- 已处理活动数 += 当前页修改的活动数
- 成功数 += 当前页修改的活动数
- （注意：当前实现假设都成功，后续需要添加失败检测）

---

#### Step 5: 更新进度显示

**5.1 计算进度**
- 如果已知总页数:
  - 进度 = (当前页码 / 总页数) × 100%
- 如果未知总页数:
  - 显示为"处理中..."

**5.2 更新UI**
- 更新进度条
- 显示当前页码 / 总页数
- 显示已处理活动数
- 显示成功/失败数量
- 如果有失败，显示失败图标

**5.3 计算预计剩余时间**
- 平均每页耗时 = (当前时间 - 开始时间) / 当前页码
- 剩余时间 = 平均每页耗时 × (总页数 - 当前页码)
- 显示: "预计剩余时间: X分X秒"

**5.4 保存任务进度**
- 更新 Chrome Storage 中的任务状态
- 包含最新的页码和统计数据

---

#### Step 6: 检查是否继续

**6.1 检查暂停状态**
- 如果用户点击了"暂停":
  - 保存当前进度到 Chrome Storage
  - 显示暂停对话框
  - 提供"继续"和"停止并保存"按钮
  - 等待用户决策

**6.1.1 继续执行前的准备工作**

当用户点击"继续"按钮时，需要重新准备执行环境：

1. **恢复任务状态**:
   - 从 Chrome Storage 读取保存的任务数据
   - 恢复场景、筛选条件、更新值
   - 恢复执行进度（当前页码、统计数据）
   - 恢复失败活动列表

2. **页面状态验证**（关键）:
   - **检查当前页码**: 
     - 从 DOM 读取当前显示的页码
     - 与保存的页码对比
     - 如果不一致，需要翻页到正确位置
   
   - **确认排序未变化**:
     - 重新验证列表仍按时间降序排列
     - 如果用户改变了排序，警告并要求重新调整
     - 排序不对会导致继续执行时遗漏或重复处理活动

3. **环境重新初始化**:
   - 重新设置 API 监听器（页面刷新后会失效）
   - 检查登录状态仍然有效
   - 验证配置（装备ID等）仍然有效

4. **决定继续策略**:
   - **策略A**: 从上次暂停的页面继续
     - 重新处理当前页（因为不确定哪些已保存成功）
     - 跳过已在"成功列表"中的活动（如果有精确记录）
   
   - **策略B**: 从下一页继续
     - 假设当前页已完整处理
     - 直接翻到下一页
     - 风险：当前页可能有未完成的

   - **推荐**: 重新处理当前页，用幂等性保证安全

5. **失败活动重试**:
   - 询问用户是否重试上次失败的活动
   - 如果重试，从失败列表开始
   - 如果跳过，继续处理后续页面

6. **继续执行检查清单**:
   - ✅ 任务状态已恢复
   - ✅ 页面在正确的页码
   - ✅ 排序方式未改变（仍按时间降序）
   - ✅ 配置仍然有效
   - ✅ API 监听器已重新设置
   - ✅ 用户已确认继续策略

**6.2 检查是否有下一页**
- 查找"下一页"按钮: `button.next_page`
- 检查按钮是否存在且未禁用

**6.3 如果有下一页**
- 点击"下一页"按钮（DOM操作）
- Strava 页面会自动发起API请求加载新页数据
- 监听器会捕获API响应（如果需要）
- 等待页面DOM更新完成（约 2000ms）
- 页码 +1
- 返回 Step 2，处理新页面

**6.4 如果没有下一页**
- 所有页面处理完成
- 进入 Step 7

---

#### Step 7: 返回第一页

**7.1 检查是否在第一页**
- 查找"上一页"按钮: `button.previous_page`
- 如果按钮不存在或已禁用，说明已在第一页

**7.2 如果不在第一页**
- 循环点击"上一页"按钮
- 每次点击后延迟 1500ms
- 直到回到第一页

**7.3 目的**
- 让用户回到初始状态
- 方便查看修改结果

---

#### Step 8: 显示完成结果

**8.1 关闭执行进度界面**
- 隐藏进度条
- 隐藏"暂停"按钮

**8.2 显示执行结果对话框**
- 标题: "批量更新完成 ✅"
- 显示统计信息:
  - ✅ 成功更新: X 个活动
  - ❌ 失败: X 个活动
  - 总耗时: X 分 X 秒

**8.3 如果有失败的活动**
- 显示"失败详情"部分
- 列出每个失败活动:
  - 活动名称
  - 活动日期
  - 失败原因（如：网络错误、权限不足等）

**8.4 提供操作按钮**
- **[关闭]** 按钮 - 关闭对话框

**8.5 清理任务状态**
- 从 Chrome Storage 中删除任务记录
- 因为任务已完成，不需要恢复

**8.6 刷新页面**
- 延迟 2 秒后自动刷新页面
- 让用户看到最新的活动数据

---

### 输出结果
- **成功更新的活动数**: number
- **失败的活动数**: number
- **失败活动列表**: FailedActivity[]
  - activityId: string
  - activityName: string
  - error: string
- **总耗时**: number (秒)

---

## 三、两个流程的关键区别

| 对比项 | 预执行 (Preview) | 真正执行 (Execute) |
|--------|------------------|-------------------|
| **目标** | 查看将要修改的活动 | 真正修改活动数据 |
| **数据源** | 监听Strava API响应 + DOM翻页 | 操作页面DOM，模拟用户手动编辑 |
| **是否修改数据** | ❌ 否 | ✅ 是 |
| **规则引擎** | 使用 Rule Engine 筛选API数据 | 使用相同的 Rule Engine 筛选活动 |
| **速度** | 快（只读取数据） | 慢（需要等待每个保存请求） |
| **进度显示** | 已扫描/总活动数 | 当前页/总页数 |
| **可中断** | 否（通常很快完成） | 是（支持暂停/继续） |
| **结果展示** | 匹配活动列表 | 成功/失败统计 |
| **错误处理** | 简单（监听失败） | 复杂（需要重试、记录失败） |

---

## 四、核心技术点

### 1. 页面归位和排序检查（基础且关键）

**这是所有操作的前提条件**

#### 1.1 页面必须归位到第一页

**原因**:
- 避免遗漏活动：如果从第5页开始，前4页会被跳过
- 确定的起始位置：从第1页开始遍历，逻辑清晰可控
- 断点续传可预测：知道第X页对应的位置

**实现**:
- 检测当前页码（从DOM或URL）
- 自动翻回第一页
- 验证已回到第一页

#### 1.2 列表必须按时间降序排列

**为什么必须按时间排序（最新在最上方）**:

1. **时间范围 Condition 才能准确工作**:
   ```
   按时间排序：
   第1页: 2024-03-15 ~ 2024-03-10
   第2页: 2024-03-09 ~ 2024-03-03
   → 时间连续，筛选准确
   
   按距离排序：
   第1页: 混合各种日期
   第2页: 混合各种日期
   → 时间混乱，无法准确筛选
   ```

2. **智能翻页优化才能生效**:
   ```
   用户设置时间范围: 2024-02-01 ~ 2024-02-28
   
   按时间排序：
   - 第8页: 2024-01-20 ~ 2024-01-15（全部早于最早时间）
   - 判断：后面的页面都更早，可以停止遍历 ✅
   
   按距离排序：
   - 无法判断是否该停止
   - 必须遍历所有页面 ❌
   ```

3. **断点续传更可靠**:
   ```
   按时间排序：
   - 暂停在第5页
   - 知道：第5页处理 2024-02-10 前后的活动
   - 继续时：从第6页（2024-02-09）往前
   - 逻辑清晰可预测 ✅
   
   按距离排序：
   - 暂停在第5页
   - 不知道：哪些时间的活动已处理
   - 继续时：无法判断应该怎么做
   - 可能遗漏或重复 ❌
   ```

4. **避免遗漏和重复**:
   - 时间排序：有明确的边界
   - 其他排序：日期混乱，容易出错

**实现**:
- 检测当前排序方式
- 验证前几个活动的时间戳是降序
- 如果不对，提示用户调整或自动调整

**如果不满足这些条件**:
- ❌ 时间范围筛选可能不准确
- ❌ 可能遗漏符合条件的活动
- ❌ 可能重复处理某些活动
- ❌ 无法使用智能翻页优化
- ❌ 断点续传不可靠

**结论**: 页面归位和时间排序是**必须满足**的前提条件，否则不应开始执行。

---

### 2. API监听技术（关键）

**为什么监听而不是主动请求**
- 不需要处理认证逻辑（Cookie、CSRF Token等）
- 不需要构造完整的请求参数
- 复用页面已有的请求逻辑
- 更难被反爬虫检测

**实现方式**
- 拦截 XMLHttpRequest 或 Fetch API
- 监听目标URL的响应
- 解析响应JSON获取数据

**配合DOM操作**
- 点击"下一页"按钮 → 触发页面请求
- 监听器捕获响应 → 获取数据
- 从页面DOM读取补充信息 → 双重验证

**优势**
- ✅ 可靠性高：复用官方逻辑
- ✅ 可控性好：同步页面状态
- ✅ 维护成本低：不依赖API细节

### 3. 规则引擎 (Rule Engine)

**术语定义**
- **Condition（条件）**: 单个筛选条件，如运动类型、时间范围、距离范围等
- **Rule（规则）**: 0个或多个 Conditions 的组合

**Rule 的执行逻辑**
- 一个 Rule 可以包含 0 到 N 个 Conditions
- 所有**启用的** Conditions 是"且"关系，必须**同时满足**
- **未启用的** Condition 会被跳过，自动视为通过
  ```
  Rule = (Condition1 未启用 OR Condition1 通过) 
         AND (Condition2 未启用 OR Condition2 通过)
         AND ...
  ```

**特殊情况**
- 如果 Rule 下没有任何启用的 Condition → 匹配**所有**活动
- 这意味着用户可以不设置任何筛选条件，批量更新所有活动

**Condition 的内部逻辑**
- 某些 Condition 内部可能有"或"关系
- 例如时间范围 Condition: 多个时间段是"或"关系
  ```
  TimeCondition = 时间段1 OR 时间段2 OR 时间段3
  ```
- 如果时间段列表为空 → Condition 未启用

**判断 Condition 是否启用的方式**
- 运动类型: 根据场景固定，通常总是启用
- 时间范围: 用户添加了至少一个时间段
- 距离范围: 根据场景判断，范围值不为默认值
- 骑行类型: 用户选择了至少一个类型

**通用性和可扩展性**
- Preview 和 Execute 共用同一个规则引擎
- 可以轻松添加新的 Condition（如海拔、心率等）
- 每个 Condition 都有"是否启用"的判断逻辑
- 不需要修改引擎核心代码

### 5. 延迟配置管理

**集中配置文件** (建议路径: `src/config/delays.ts`)

所有延迟参数应该集中在配置文件中，方便开发时调整：

```typescript
export const DELAYS = {
  // DOM操作延迟
  QUICK_EDIT_CLICK: 500,      // 点击快速编辑后等待
  FORM_FILL: 300,             // 填充表单后等待
  SUBMIT_SAVE: 1500,          // 提交保存后等待
  PAGE_LOAD: 2000,            // 翻页后等待页面加载
  
  // 智能延迟（待实现）
  RANDOM_MIN: 0,              // 随机延迟最小值
  RANDOM_MAX: 1000,           // 随机延迟最大值
  
  // API监听超时
  API_TIMEOUT: 5000,          // API响应超时时间
  
  // 重试延迟
  RETRY_BASE: 1000,           // 重试基础延迟
  RETRY_MULTIPLIER: 2,        // 重试延迟倍数（指数退避）
}

// 开发模式：可以缩短延迟加快测试
export const DEV_DELAYS = {
  ...DELAYS,
  QUICK_EDIT_CLICK: 200,
  FORM_FILL: 100,
  SUBMIT_SAVE: 500,
  PAGE_LOAD: 1000,
}
```

**使用方式**:
```typescript
import { DELAYS } from '@/config/delays'

await delay(DELAYS.QUICK_EDIT_CLICK)
await delay(DELAYS.FORM_FILL)
```

**优势**:
- ✅ 集中管理，便于调整
- ✅ 开发和生产环境可以使用不同配置
- ✅ 便于 A/B 测试找到最优延迟值
- ✅ 代码中的延迟值有明确的语义
- ✅ 可以快速切换不同的延迟策略

**配置文件已创建**:
- 路径: `src/config/delays.ts`
- 包含生产和开发两套配置
- 提供工具函数: `delay()`, `smartDelay()`, `getRetryDelay()`
- 已在 `stravaUpdater.ts` 中应用

### 4. DOM 选择器集中管理

**重要**: 所有涉及的 DOM 选择器（CSS Selector / XPath）都应该放在一个配置文件中管理

**建议路径**: `src/config/selectors.ts`

**需要管理的选择器类型**:
- 活动列表相关: 活动行、快速编辑按钮
- 表单字段: 骑行类型、自行车、跑鞋、隐私设置等
- 操作按钮: 提交、取消、翻页按钮
- 筛选面板: 各类筛选下拉框
- 导航元素: Athlete ID 获取等
- 页面状态: 页码、加载指示器等

**优势**:
- ✅ Strava 改版时只需修改一个文件
- ✅ 选择器有明确的语义，提高代码可读性
- ✅ 可以为关键选择器提供备用方案（降级策略）
- ✅ 便于批量测试选择器的有效性
- ✅ 避免选择器硬编码分散在各处

### 6. 进度计算方式
**预执行**: 基于活动数量
```
进度 = 已扫描活动数 / 总活动数
```

**真正执行**: 基于页码
```
进度 = 当前页码 / 总页数
```

### 7. 失败处理（待完善）
当前实现较简单，需要增强：
- 检测保存请求是否成功
- 失败时自动重试（最多3次）
- 记录失败的具体原因
- 连续失败时自动暂停

### 8. 任务状态保存
保存到 Chrome Storage Local:
```
{
  scenario: '场景类型',
  filters: '筛选条件',
  updates: '更新值',
  progress: {
    currentPage: '当前页码',
    totalPages: '总页数',
    statistics: {
      success: '成功数',
      failed: '失败数'
    },
    failedList: ['失败活动列表']
  },
  timestamp: '时间戳'
}
```

### 9. 页面加载检测（待完善）
当前使用固定延迟，可以改进为：
- 检查页面高亮的页码是否变化
- 检查活动列表容器是否更新
- 使用 MutationObserver 监听DOM变化
- 配合API监听器，确认数据已返回

---

## 五、预览与执行的数据流

```
用户配置 (Filters + Updates)
        ↓
    构建 Rule (0-N 个 Conditions)
        ↓
      判断 Conditions 是否启用
        ↓
    ┌───┴───┐
    ↓       ↓
 Preview   Execute
    ↓       ↓
┌───────────┐ ┌────────────┐
│ DOM翻页   │ │ DOM 模拟   │
│ 点击按钮  │ │ 点击编辑   │
└─────┬─────┘ └─────┬──────┘
      ↓             ↓
┌───────────┐ ┌────────────┐
│ 监听API   │ │ Rule Engine│
│ 响应拦截  │ │ 匹配活动   │
└─────┬─────┘ └─────┬──────┘
      ↓             ↓
┌───────────┐ ┌────────────┐
│Rule Engine│ │ 填充表单   │
│ 匹配活动  │ │ + 提交保存 │
└─────┬─────┘ └─────┬──────┘
      ↓             ↓
┌───────────┐ ┌────────────┐
│ 展示列表  │ │ 统计结果   │
└───────────┘ └────────────┘
```

**共享的核心组件**：
- Rule Engine（规则引擎）：Preview 和 Execute 使用完全相同的匹配逻辑

**Rule Engine 的行为**：
- 如果有启用的 Conditions → 只匹配满足所有条件的活动
- 如果没有启用的 Conditions → 匹配**所有**活动

---

## 六、后续优化方向

### 预执行优化
1. **优化API监听**
   - 使用更精确的URL匹配规则
   - 添加超时处理（如果API响应超时）
   - 支持同时监听多个请求
   
2. **分页加载结果**
   - 不要等所有页扫描完才显示
   - 边扫描边展示匹配的活动
   
3. **取消扫描**
   - 添加"取消"按钮
   - 随时中断预览过程
   - 清理未完成的监听器

4. **缓存扫描结果**
   - 如果用户返回修改条件再预览
   - 可以复用之前捕获的API数据

### 执行优化
1. **更精确的成功/失败检测**
   - 监听保存请求的响应
   - 检查是否返回错误

2. **智能重试机制**
   - 失败时自动重试3次
   - 指数退避: 1s → 2s → 4s

3. **并发控制**
   - 当前是串行处理（一次一页）
   - 可以考虑一次处理多个活动（但要避免被限流）

4. **断点续传**
   - 保存详细的执行状态
   - 浏览器崩溃后可以恢复

5. **智能翻页优化（基于 Rule Engine）**
   - 如果当前页所有活动都不满足时间范围 Condition
   - 可以直接停止，不再翻页
   - 提前终止，节省时间

6. **Rule Engine 优化**
   - 短路求值：第一个启用的 Condition 不满足就立即返回 false
   - Condition 排序：把最容易排除的 Condition 放前面执行
   - 跳过未启用的 Condition：提前判断避免不必要的计算
   - 缓存计算结果：避免重复计算相同的 Condition
   - 空 Rule 快速通路：如果没有启用的 Condition，直接返回 true

---

## 七、关键假设与限制

### 当前假设
1. **Strava页面结构稳定**
   - CSS选择器不会频繁变化
   - DOM结构保持一致

2. **快速编辑功能可用**
   - 所有活动都支持快速编辑
   - 快速编辑覆盖所需的字段

3. **API响应格式稳定**
   - 监听的API端点不变更
   - 响应JSON结构保持一致

4. **保存请求不会被限流**
   - Strava不会检测批量操作
   - 或者延迟足以避免限流

### 技术限制
1. **采用监听而非主动请求**
   - 优势: 不需要处理认证、更稳定
   - 限制: 必须等待页面自己发起请求
   - 必须通过DOM操作触发翻页

2. **依赖DOM操作**
   - 页面改版会影响功能
   - 需要持续维护选择器
   - 需要适当的延迟等待

3. **单线程执行**
   - JavaScript单线程限制
   - 执行期间会阻塞其他操作
   - 但可以通过异步保持响应

---

## 八、文件结构和函数规划

### 目录结构

```
src/
├── config/           # 配置文件
├── core/             # 核心业务逻辑
├── engine/           # 执行引擎
├── utils/            # 工具函数
├── services/         # 服务层（API调用）
├── types/            # 类型定义
└── components/       # UI组件
```

---

### 1. 配置文件 (src/config/)

#### 1.1 `delays.ts` ✅ (已创建)
延迟配置管理

**导出常量**:
- `DELAYS` - 生产环境延迟配置
- `DEV_DELAYS` - 开发环境延迟配置
- `CURRENT_DELAYS` - 当前使用的延迟配置

**函数**:
- `delay(ms: number)` - 基础延迟函数
- `smartDelay(baseDelay: number)` - 智能延迟（加随机）
- `getRetryDelay(retryCount: number)` - 计算重试延迟

---

#### 1.2 `selectors.ts`
DOM 选择器集中管理

**导出常量**:
- `ACTIVITY_SELECTORS` - 活动列表相关选择器
- `FORM_SELECTORS` - 表单字段选择器
- `BUTTON_SELECTORS` - 操作按钮选择器
- `FILTER_SELECTORS` - 筛选面板选择器
- `NAV_SELECTORS` - 导航元素选择器
- `STATE_SELECTORS` - 页面状态选择器
- `FALLBACK_SELECTORS` - 备用选择器方案

**函数**:
- `querySelector(selectors: string[])` - 尝试多个选择器，返回第一个匹配
- `querySelectorAll(selectors: string[])` - 尝试多个选择器，返回所有匹配

---

#### 1.3 `constants.ts`
常量配置

**导出常量**:
- `API_ENDPOINTS` - API 端点配置
  - `TRAINING_ACTIVITIES` - 训练活动列表 API
  - `ACTIVITY_UPDATE` - 活动更新 API
- `STRAVA_URLS` - Strava URL 配置
  - `TRAINING_LOG` - 训练日志页面
- `STORAGE_KEYS` - Chrome Storage 键名
  - `TASK_STATE` - 任务状态键
  - `TASK_TIMESTAMP` - 任务时间戳键
- `TASK_EXPIRY_TIME` - 任务过期时间（24小时）
- `MAX_RETRIES` - 最大重试次数
- `SCENARIO_TYPES` - 场景类型枚举

---

### 2. 核心业务逻辑 (src/core/)

#### 2.1 `pageManager.ts`
页面状态管理（归位、排序检查）

**函数**:
- `getCurrentPage()` - 获取当前页码
  - 从 DOM 或 URL 读取当前页码
  - 返回页码数字

- `goToFirstPage()` - 回到第一页
  - 检测当前是否在第一页
  - 如果不是，连续点击"上一页"直到第一页
  - 每次点击后等待页面加载
  - 验证已回到第一页

- `checkSortOrder()` - 检查排序方式
  - 检测当前排序设置
  - 验证前几个活动的时间戳是否降序
  - 返回排序是否正确

- `verifySortByDate()` - 验证按时间降序
  - 获取前3个活动的时间戳
  - 检查是否 timestamp1 > timestamp2 > timestamp3
  - 返回验证结果

- `adjustSortOrder()` - 调整排序（可选）
  - 尝试通过 DOM 操作调整排序
  - 等待页面更新
  - 验证调整是否成功

- `isOnTrainingLogPage()` - 检查是否在训练日志页面
  - 验证 URL 包含正确路径
  - 验证必要的 DOM 元素存在
  - 返回检查结果

- `preparePageForExecution()` - 执行前页面准备
  - 综合执行所有检查
  - 归位到第一页
  - 验证排序
  - 返回准备是否成功

---

#### 2.2 `ruleEngine.ts`
规则引擎（筛选匹配逻辑）

**函数**:
- `buildRule(filters: FilterConfig)` - 构建 Rule
  - 根据用户配置构建 Rule 对象
  - 包含所有 Conditions
  - 返回 Rule 实例

- `isConditionEnabled(condition: Condition)` - 判断 Condition 是否启用
  - 检查该条件是否被用户设置
  - 返回启用状态

- `matchActivity(activity: Activity, rule: Rule)` - 匹配活动
  - 执行 Rule 的所有 Conditions
  - 只有全部通过才返回 true
  - 支持短路求值优化

- `matchSportType(activity: Activity, sportTypes: SportType[])` - 运动类型匹配
  - 判断活动的运动类型是否在列表中
  - 返回是否匹配

- `matchTimeRanges(activity: Activity, timeRanges: DateRange[])` - 时间范围匹配
  - 判断活动是否落在任意一个时间段内
  - 返回是否匹配

- `matchDistanceRange(activity: Activity, range: [number, number])` - 距离范围匹配
  - 判断活动距离是否在范围内
  - 处理单位转换（米 → 公里/英里）
  - 返回是否匹配

- `matchRideTypes(activity: Activity, rideTypes: RideType[])` - 骑行类型匹配
  - 判断活动的骑行类型是否在列表中
  - 返回是否匹配

- `getMatchedActivities(activities: Activity[], rule: Rule)` - 批量匹配
  - 对活动列表执行 Rule 匹配
  - 返回所有匹配的活动

---

#### 2.3 `apiListener.ts`
API 请求监听器

**函数**:
- `setupApiListener()` - 设置 API 拦截器
  - 拦截 XMLHttpRequest 或 Fetch
  - 监听目标 URL
  - 注册响应处理器

- `interceptTrainingActivitiesApi(callback: Function)` - 拦截训练活动 API
  - 监听 `/athlete/training_activities` 请求
  - 捕获响应数据
  - 调用回调函数处理数据

- `parseApiResponse(response: any)` - 解析 API 响应
  - 提取活动列表
  - 提取总数、页码等元数据
  - 返回解析后的数据

- `waitForApiResponse(timeout: number)` - 等待 API 响应
  - 设置超时等待
  - 返回 Promise，响应到达时 resolve
  - 超时则 reject

- `cleanupListener()` - 清理监听器
  - 移除拦截器
  - 清理缓存数据

---

#### 2.4 `taskManager.ts`
任务状态管理

**函数**:
- `saveTaskState(state: TaskState)` - 保存任务状态
  - 将任务配置和进度保存到 Chrome Storage
  - 包含场景、筛选、更新值、进度等
  - 添加时间戳

- `loadTaskState()` - 加载任务状态
  - 从 Chrome Storage 读取任务数据
  - 返回任务状态对象，如果没有则返回 null

- `hasUnfinishedTask()` - 检查是否有未完成任务
  - 检查存储中是否有任务
  - 检查任务是否过期（24小时）
  - 返回检查结果

- `clearTaskState()` - 清除任务状态
  - 从存储中删除任务数据
  - 清理相关缓存

- `updateTaskProgress(progress: ProgressData)` - 更新任务进度
  - 更新当前页码
  - 更新统计数据（成功、失败）
  - 保存到存储

- `isTaskExpired(timestamp: number)` - 判断任务是否过期
  - 计算时间差
  - 与过期时间对比
  - 返回是否过期

---

### 3. 执行引擎 (src/engine/)

#### 3.1 `previewEngine.ts`
预览执行引擎

**函数**:
- `startPreview(config: PreviewConfig)` - 开始预览
  - 执行预览前准备检查
  - 初始化预览状态
  - 开始扫描流程
  - 返回 Promise，完成时 resolve

- `scanAllPages(rule: Rule, onProgress: Function)` - 扫描所有页面
  - 从第一页开始遍历
  - 对每页的活动执行 Rule 匹配
  - 调用进度回调函数
  - 收集所有匹配的活动
  - 返回匹配活动列表

- `scanCurrentPage(rule: Rule)` - 扫描当前页
  - 等待 API 响应（监听器捕获）
  - 解析活动数据
  - 执行 Rule 匹配
  - 返回当前页匹配的活动

- `goToNextPageForPreview()` - 翻到下一页（预览）
  - 点击"下一页"按钮
  - 等待 API 响应
  - 返回是否成功翻页

- `checkCanStopEarly(activities: Activity[], rule: Rule)` - 检查是否可提前停止
  - 智能翻页优化
  - 检查当前页所有活动是否都早于最早时间
  - 返回是否可以停止

- `calculatePreviewProgress(current: number, total: number)` - 计算预览进度
  - 计算百分比
  - 返回进度数据

---

#### 3.2 `executeEngine.ts`
执行引擎

**函数**:
- `startExecution(config: ExecutionConfig)` - 开始执行
  - 执行前准备检查（页面归位、排序）
  - 初始化执行环境
  - 开始批量更新流程
  - 返回 Promise，完成时 resolve

- `processAllPages(rule: Rule, updates: UpdateConfig, onProgress: Function)` - 处理所有页面
  - 从第一页（或恢复的页码）开始
  - 逐页处理活动
  - 调用进度回调
  - 支持暂停和继续
  - 返回执行结果

- `processCurrentPage(rule: Rule, updates: UpdateConfig)` - 处理当前页
  - 点击所有快速编辑按钮
  - 筛选匹配的活动
  - 填充修改值
  - 提交所有修改
  - 返回处理结果（成功/失败数）

- `openAllQuickEdits()` - 打开所有快速编辑
  - 找到所有快速编辑按钮
  - 依次点击
  - 等待编辑表单出现

- `fillActivityForm(activity: Activity, updates: UpdateConfig)` - 填充活动表单
  - 根据场景填充不同字段
  - 设置装备、隐私、类型等
  - 触发表单更新事件

- `submitAllForms()` - 提交所有表单
  - 找到所有提交按钮
  - 依次点击
  - 等待提交完成

- `goToNextPageForExecution()` - 翻到下一页（执行）
  - 点击"下一页"按钮
  - 等待页面加载
  - 返回是否成功翻页

- `goBackToFirstPage()` - 返回第一页
  - 完成后回到初始位置
  - 连续点击"上一页"
  - 等待页面加载

- `handleExecutionError(error: Error, activity: Activity)` - 处理执行错误
  - 记录错误信息
  - 添加到失败列表
  - 决定是否重试
  - 返回处理结果

- `retryFailedActivity(activity: Activity, retryCount: number)` - 重试失败活动
  - 使用指数退避延迟
  - 重新执行更新操作
  - 返回重试结果

- `checkShouldPause()` - 检查是否应该暂停
  - 检查用户暂停标志
  - 检查连续失败次数
  - 返回是否应暂停

- `pauseExecution(state: ExecutionState)` - 暂停执行
  - 保存当前状态
  - 显示暂停对话框
  - 等待用户决策

- `resumeExecution(savedState: TaskState)` - 恢复执行
  - 恢复任务状态
  - 重新准备执行环境
  - 验证页面状态
  - 从保存的位置继续

- `calculateExecutionProgress(currentPage: number, totalPages: number)` - 计算执行进度
  - 计算翻页进度
  - 计算剩余时间
  - 返回进度数据

---

### 4. 工具函数 (src/utils/)

#### 4.1 `domHelper.ts`
DOM 操作辅助工具

**函数**:
- `clickElement(selector: string)` - 点击元素
  - 查找元素
  - 触发点击事件
  - 返回是否成功

- `setSelectValue(selector: string, value: string)` - 设置下拉框值
  - 查找 select 元素
  - 设置 value
  - 触发 change 事件

- `getElementText(selector: string)` - 获取元素文本
  - 查找元素
  - 返回文本内容

- `waitForElement(selector: string, timeout: number)` - 等待元素出现
  - 使用 MutationObserver 或轮询
  - 超时则 reject
  - 返回 Promise

- `isElementVisible(selector: string)` - 检查元素是否可见
  - 检查元素存在性
  - 检查 display、visibility 等
  - 返回可见状态

- `getActivityTimestamps(count: number)` - 获取活动时间戳
  - 获取前 N 个活动的时间戳
  - 用于验证排序
  - 返回时间戳数组

---

#### 4.2 `storageHelper.ts`
Chrome Storage 辅助工具

**函数**:
- `saveToStorage(key: string, value: any)` - 保存到存储
  - 使用 chrome.storage.local
  - 序列化数据
  - 返回 Promise

- `loadFromStorage(key: string)` - 从存储读取
  - 使用 chrome.storage.local
  - 反序列化数据
  - 返回 Promise

- `removeFromStorage(key: string)` - 从存储删除
  - 删除指定键
  - 返回 Promise

- `clearAllStorage()` - 清空所有存储
  - 清空插件相关的所有数据
  - 返回 Promise

---

#### 4.3 `validator.ts`
验证工具

**函数**:
- `validatePageState()` - 验证页面状态
  - 检查是否在正确页面
  - 检查必要元素存在
  - 返回验证结果

- `validateConfig(config: any)` - 验证配置有效性
  - 检查场景和更新值匹配
  - 检查必填字段
  - 返回验证结果和错误信息

- `validateGearId(gearId: string, type: 'bike' | 'shoe')` - 验证装备ID有效性
  - 检查装备是否存在
  - 检查装备是否退役
  - 返回验证结果

- `validateTimeRange(range: DateRange)` - 验证时间范围
  - 检查起止日期有效性
  - 检查起始日期早于结束日期
  - 返回验证结果

- `isLoggedIn()` - 检查登录状态
  - 尝试获取 Athlete ID
  - 检查认证 Cookie
  - 返回登录状态

---

#### 4.4 `formatHelper.ts`
格式化辅助工具

**函数**:
- `formatDistance(meters: number, unit: 'km' | 'mi')` - 格式化距离
  - 转换单位
  - 格式化显示
  - 返回格式化字符串

- `formatTime(seconds: number)` - 格式化时间
  - 转换为 HH:MM:SS 格式
  - 返回格式化字符串

- `formatDate(timestamp: number)` - 格式化日期
  - 转换时间戳为可读日期
  - 返回格式化字符串

- `formatProgress(current: number, total: number)` - 格式化进度
  - 计算百分比
  - 返回进度字符串

---

### 5. 服务层 (src/services/)

#### 5.1 `stravaApi.ts` ✅ (已存在，需补充)
Strava API 调用服务

**现有函数**:
- `getAthleteId()` - 获取运动员 ID
- `fetchShoes()` - 获取跑鞋列表
- `fetchBikes()` - 获取自行车列表

**需要补充的函数**:
- `fetchTrainingActivities(page: number, perPage: number)` - 获取训练活动列表
  - 调用训练活动 API
  - 返回活动列表和元数据

- `updateActivity(activityId: string, data: UpdateData)` - 更新活动
  - 调用更新 API
  - 返回更新结果

- `getCSRFToken()` - 获取 CSRF Token
  - 从页面 meta 标签获取
  - 返回 token 字符串

---

### 6. 类型定义 (src/types/)

#### 6.1 `activity.ts` ✅ (已存在，需补充)

**需要补充的类型**:
- `Rule` - 规则类型
- `Condition` - 条件类型
- `TaskState` - 任务状态类型
- `ExecutionState` - 执行状态类型
- `ProgressData` - 进度数据类型

#### 6.2 `strava.ts` ✅ (已存在)

**现有类型**: BulkEditFields, UpdateStatus, VisibilityOption

---

### 7. 主入口文件

#### 7.1 `contents/strava-bulk-edit.tsx` ✅ (已存在)
Content Script 主入口

**主要职责**:
- 检测页面
- 注入批量更新按钮
- 打开配置对话框
- 协调各个模块

---

## 九、模块依赖关系

```
UI Components
    ↓
engine/ (previewEngine, executeEngine)
    ↓
core/ (ruleEngine, pageManager, apiListener, taskManager)
    ↓
utils/ (domHelper, storageHelper, validator, formatHelper)
    ↓
services/ (stravaApi)
    ↓
config/ (delays, selectors, constants)
    ↓
types/
```

---

## 十、开发顺序建议

### Phase 1: 基础设施（1-2天）
1. 完善 `config/selectors.ts` - DOM 选择器
2. 完善 `config/constants.ts` - 常量配置
3. 补充类型定义 `types/`

### Phase 2: 工具层（2-3天）
4. 实现 `utils/domHelper.ts` - DOM 操作
5. 实现 `utils/storageHelper.ts` - 存储操作
6. 实现 `utils/validator.ts` - 验证工具
7. 实现 `utils/formatHelper.ts` - 格式化工具

### Phase 3: 核心逻辑（3-4天）
8. 实现 `core/pageManager.ts` - 页面管理
9. 实现 `core/ruleEngine.ts` - 规则引擎
10. 实现 `core/apiListener.ts` - API 监听
11. 实现 `core/taskManager.ts` - 任务管理

### Phase 4: 执行引擎（4-5天）
12. 实现 `engine/previewEngine.ts` - 预览引擎
13. 实现 `engine/executeEngine.ts` - 执行引擎

### Phase 5: 集成和测试（3-4天）
14. 集成所有模块
15. UI 与引擎连接
16. 端到端测试
17. 错误处理完善

**总计**: 约 2-3 周开发时间

---

**文档完成！✅**

此文档详细描述了预执行和真正执行的完整流程，以及完整的文件结构和函数规划，可作为开发和测试的参考。

